<template>
  <div class="wrapper">
    <ul class="el-upload-list el-upload-list--picture-card">
      <li
        v-for="(item, index) in nodeImages"
        :key="index"
        class="el-upload-list__item is-success"
      >
        <img
          v-if="item.name.endsWith('pdf')"
          style="width: inherit"
          src="../../assets/images/pdf.svg"
        >
        <img
          v-if="item.name.endsWith('pptx')"
          style="width: inherit"
          src="../../assets/images/ppt.svg"
        >
        <img
          v-else-if="item.name.endsWith('txt')"
          style="width: inherit"
          src="../../assets/images/txt.svg"
        >
        <img
          v-else-if="item.name.endsWith('xlsx') || item.name.endsWith('xls')"
          style="width: inherit"
          src="../../assets/images/xls.svg"
        >
        <img
          v-else-if="item.name.endsWith('doc') || item.name.endsWith('docx')"
          style="width: inherit"
          src="../../assets/images/word.svg"
        >
        <video
          v-else-if="item.name.endsWith('mp4')"
          style="width: inherit"
          autoplay
          :src="item.address"
        />
        <!-- <img
          style="width: inherit"
          v-else-if="
            !item.name.endsWith('pdf') &&
            !item.name.endsWith('pptx') &&
            !item.name.endsWith('txt') &&
            !item.name.endsWith('doc') &&
            !item.name.endsWith('docx') &&
            !item.name.endsWith('xlsx')
          "
          src="../../assets/images/other.svg"
        /> -->
        <el-image v-else :src="item.address" />
        <span class="el-upload-list__item-actions">
          <!-- <span
            v-if="
              !item.name.endsWith('pdf') &&
              !item.name.endsWith('pptx') &&
              !item.name.endsWith('txt') &&
              !item.name.endsWith('doc') &&
              !item.name.endsWith('docx') &&
              !item.name.endsWith('xlsx')
            "
            class="el-upload-list__item-preview"
            @click="handlePreview(item)"
          >
            <i class="el-icon-zoom-in"></i>
          </span> -->
          <span
            class="el-upload-list__item-delete"
            @click="handleDownload(item)"
          >
            <i class="el-icon-download" />
          </span>
          <span class="el-upload-list__item-delete" @click="handleRemove(item)">
            <i class="el-icon-delete" />
          </span>
        </span>
      </li>
      <li class="el-upload-list__item" style="border: none">
        <el-upload
          class="upload-demo"
          :before-upload="handleBeforeUpload"
          name="filename"
          :headers="header"
          :action="baseApi + '/api/cyyPlanMaster/upload'"
          :on-success="afterUploadSucess"
          :show-file-list="false"
          list-type="picture-card"
        >
          <i slot="default" class="el-icon-plus" />
        </el-upload>
      </li>
    </ul>
    <el-image-viewer
      v-if="showViewer"
      class="hideImgDiv"
      :on-close="
        () => {
          showViewer = false;
        }
      "
      :url-list="priviewImageList"
    />
    <!-- <el-image
      v-if="imageList.length > 0"
      src="/image/common/nodata.jpg"
      fit="fit"
    ></el-image> -->
  </div>
</template>
<script>
import request from '@/utils/request'
import ElImageViewer from 'jintu-ui/packages/image/src/image-viewer'
import { mapGetters } from 'vuex'
import { getToken } from '@/utils/auth'

export default {
  components: {
    ElImageViewer
  },
  props: {
    imageList: Array
  },
  data() {
    return {
      showViewer: false,
      priviewImageList: [],
      showPdf: false,
      header: {
        Authorization: getToken()
      },
      addressArr: [],
      nodeImages: []
    }
  },
  created() {
    // console.log(this.imageList);
    this.nodeImages = this.imageList
    // if (this.imageList.length > 0) {
    //   this.imageList.forEach((item) => {
    //     let obj = {
    //       address: this.baseApi + "/file" + item.address,
    //       name: item.name,
    //     };
    //     this.nodeImages.push(obj);
    //   });
    // }
    // console.log(this.nodeImages);
  },
  computed: {
    ...mapGetters(['baseApi'])
  },
  methods: {
    handleBeforeUpload(file) {
      // debugger
      // console.log(file);
    },

    handlePreview(file) {
      if (file.name.endsWith('pdf')) {
        // this.currentPdfUrl = file.address;
        window.open(file.address, '_blank')
        return false
      }
      // console.log(file);
      if (this.nodeImages.length > 0) {
        const imageList = this.nodeImages.map((t) => t.address)
        const index = imageList.findIndex((t) => t === file.address)
        const frontItems = imageList.splice(0, index)
        // frontItems.reverse()
        this.priviewImageList = imageList.concat(frontItems)
      }
      this.showViewer = true
    },
    handleDownload(file) {
      // debugger
      try {
        const address = file.address
        if (address.endsWith('pdf')) {
          // this.downloadPDF(address, file.name);
          var tempLink = document.createElement('a')
          tempLink.style.display = 'none'
          tempLink.href = address
          tempLink.setAttribute('download', file.name)
          tempLink.setAttribute('target', '_blank')
          document.body.appendChild(tempLink)
          tempLink.click()
          document.body.removeChild(tempLink)
        } else if (address.endsWith('pdf')) {
          window.open(file.address, '_blank')
        } else if (address.endsWith('pptx')) {
          window.open(file.address, '_blank')
        } else if (address.endsWith('xlsx')) {
          window.open(file.address, '_blank')
        } else if (address.endsWith('xls')) {
          window.open(file.address, '_blank')
        } else if (address.endsWith('doc')) {
          window.open(file.address, '_blank')
        } else if (address.endsWith('docx')) {
          window.open(file.address, '_blank')
        } else {
          const name = address.substr(address.lastIndexOf('/') + 1)
          this.downloadIamge(address, name)
        }
      } catch (err) {
        // console.log(err);
        this.$message({
          type: 'error',
          message: '图片下载失败'
        })
      }
    },
    afterUploadSucess(response, file, fileList) {
      // debugger;
      // console.log(fileList);
      let arr = []
      arr = fileList.map((item) => {
        return item.response
      })
      // console.log(arr);
      this.nodeImages = []
      arr.forEach((item) => {
        const obj = {
          address: this.baseApi + '/file' + item.address,
          name: item.name
        }
        this.nodeImages.push(obj)
      })
      console.log(this.imageList)
      this.addressArr = arr.map((item) => {
        return this.baseApi + '/file' + item.address
      })
      // console.log(this.addressArr);
      this.$emit('sendAddress', this.addressArr)
    },
    handleRemove(file) {
      console.log(file)
      this.$confirm('确定要删除该图片吗?', '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }).then(() => {
        const target = this.imageList.filter((t) => {
          return t.address !== file.address
        })
        console.log(target)
        this.imageList = target
        const deleteIdArr = target.map((item) => {
          return item.address
        })
        this.$emit('sendAddress', deleteIdArr)
      })
    },
    // 此方法下载后pdf无法打开
    downloadPDF(url, name) {
      request({
        method: 'get',
        responseType: 'blob',
        headers: {
          'Content-Type': 'application/pdf;charset=UTF-8'
        },
        url: url
      })
        .then((res) => {
          this.fileDownload(res, name)
        })
        .catch(() => {
          this.$message.error('网络请求出错')
          // 调试阶段可以看看报的什么错
          // console.log("error",error)
        })
    },
    fileDownload: function(data, fileName) {
      const blob = new Blob([data], {
        // type类型后端返回来的数据中会有，根据自己实际进行修改
        type: 'application/pdf;charset=utf-8'
      })
      const filename = fileName
      if (typeof window.navigator.msSaveBlob !== 'undefined') {
        window.navigator.msSaveBlob(blob, filename)
      } else {
        var blobURL = window.URL.createObjectURL(blob)
        // 创建隐藏<a>标签进行下载
        var tempLink = document.createElement('a')
        tempLink.style.display = 'none'
        tempLink.href = blobURL
        tempLink.setAttribute('download', filename)
        if (typeof tempLink.download === 'undefined') {
          tempLink.setAttribute('target', '_blank')
        }
        document.body.appendChild(tempLink)
        tempLink.click()
        document.body.removeChild(tempLink)
        window.URL.revokeObjectURL(blobURL)
      }
    },
    downloadIamge(imgsrc, name) {
      // 下载图片地址和图片名
      // let suffix = 'jpeg'
      name = name || 'image'
      // const index = name.lastIndexOf('.')
      // if (index >= 0) {
      //   suffix = name.substr(index + 1)
      // }
      const image = new Image()
      // 解决跨域 Canvas 污染问题
      image.setAttribute('crossOrigin', 'anonymous')
      image.onload = function() {
        const canvas = document.createElement('canvas')
        canvas.width = image.width
        canvas.height = image.height
        const context = canvas.getContext('2d')
        context.drawImage(image, 0, 0, image.width, image.height)
        const url = canvas.toDataURL('image/png') // 得到图片的base64编码数据
        const a = document.createElement('a') // 生成一个a元素
        const event = new MouseEvent('click') // 创建一个单击事件
        a.download = name || 'photo' // 设置图片名称
        a.href = url // 将生成的URL设置为a.href属性
        a.dispatchEvent(event) // 触发a的单击事件
      }
      image.src = imgsrc
    }
  }
}
</script>
<style lang="scss" scoped>
.wrapper {
  height: 100%;
  width: 100%;
  padding: 10px;

  .el-image {
    width: 100%;

    .img {
      width: 100%;
      height: 100%;
    }
  }

  .hideImgDiv .el-image__inner {
    display: none;
  }
}
</style>
